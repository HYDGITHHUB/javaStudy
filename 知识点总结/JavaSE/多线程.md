## 多线程

可以让程序充分应用CPU资源，提高程序的运行效率。从而解决高并发带来的负载均衡问题。

Java 中实现多线程的常用方式有两种：继承 Thread 类，实现 Runnable 接口。

### 1. 实现方式

#### 1.1 继承 Thread 类

Thread 是 JDK 提供的一个线程类。

通过 Thread 来创建线程对象，让线程对象去执行某一个业务逻辑（任务）

1、创建自定义类继承 Thread 类。

2、重写 run 方法，将线程需要执行的任务写入 run 。

3、创建 Thread 对象执行。

```java
package com.southwind.demo1;

public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("取快递------");
        }
    }
}
```

```java
package com.southwind.demo1;

public class Test3 {
    public static void main(String[] args) {
        //创建线程对象
        MyThread thread1 = new MyThread();
        //启动线程
        thread1.start();
    }
}
```

启动线程一定要使用 start，绝对不能使用 run，run 方法虽然是线程执行任务的入口，但是直接调用就相当于普通对象的方法执行，并没有开启线程去执行。

调用 start 之后，线程才会去争夺 CPU 资源，实现“同时运行”。

#### 1.2 实现 Runable 接口

1、创建自定义类实现 Runnable 接口。

2、实现 run 方法。

3、创建 Thread 对象，将 Runnable 对象注入 Thread 对象，进行运行。

```java
package com.southwind.demo2;

public class MyRunnable1 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("------------点外卖");
        }
    }
}
```

```java
package com.southwind.demo2;

public class Test {
    public static void main(String[] args) {
        //创建 Runnable 对象
        MyRunnable1 runnable1 = new MyRunnable1();
        //创建 Thread 对象
        Thread thread1 = new Thread(runnable1);
        //启动线程
        thread1.start();

        MyRunnable2 runnable2 = new MyRunnable2();
        Thread thread2 = new Thread(runnable2);
        thread2.start();
    }
}
```

#### 1.3 两种方式的区别

本质上是一样的，区别在于继承 Thread 类的方式，直接将线程和任务进行绑定，将业务逻辑代码直接写入线程类中。

实现 Runnable 接口的方式，实现了线程和任务的解耦合，单独将任务分离出来，使用的时候，将它注入线程中，完成任何和线程的绑定。

实际开发中，应该使用哪种方式？

使用实现 Runnable 接口的方式，因为它实现了解耦合，程序的灵活性和扩展性就更好。

线程和任务

任务就是具体的业务逻辑（取快递、点外卖）

线程就是来执行任务的对象（张三、李四），多线程就是让他们同时执行

### 2. 线程的状态

线程一共有 5 种状态，在特定的情况下，线程可以在不同的状态之间切换，5 种状态如下：

- 创建状态：实例化一个线程对象，还未启动。
- 就绪状态：创建好的线程对象调用 start()，进入线程池等待抢占 CPU 资源。
- 运行状态：线程获取了 CPU 资源，在一定的时间内执行任务。
- 阻塞状态：正在运行的线程暂停执行任务，释放所占用的 CPU 资源。解除阻塞之后也不能直接回到运行状态，而是重新回到就绪状态，等待获取 CPU 资源。
- 终止状态：线程运行完毕或者因为异常导致线程终止运行。

![image-20200623110304493](C:\Users\userhan\AppData\Roaming\Typora\typora-user-images\image-20200623110304493.png)

### 3. 线程调度

#### 3.1 线程休眠

##### 3.1.1 sleep

休眠是指让当前线程暂停执行，从运行状态进入阻塞状态，将 CPU 资源让给其他线程的一种调度方法，通过调用 sleep() 方法来实现。

```java
public static native void sleep(long millis) throws InterruptedException;
```

sleep 是本地方法，什么是本地方法？

Java 是面向应用层的编程语言，无法管理底层操作系统，如果 Java 需要进行底层操作怎么办？通过本地方法来实现，本地方法就是用 C++/C 实现的方法，封装成动态链接库，Java 可以直接调用。

```
()->{
    for (int i = 0; i < 100; i++) {
        System.out.println(i);
    }
}
```

```java
package com.southwind.demo3;

public class Test {
    public static void main(String[] args) {
        new Thread(()->{
            for (int i = 0; i < 100; i++) {
                if(i == 10){
                    try {
                        Thread.sleep(3000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(i);
            }
        }).start();
    }
}
```

如果使用 Lambda 表达式，遇到异常就需要直接 try-catch 处理，不能往外抛。

##### 3.1.2 wait

```java
//无限期休眠
try {
    this.wait();
} catch(InterruptedException e) {
    e.printStackTrace();
}
//唤醒
this.notify();
```

#### 3.2 线程合并

将指定的某个线程加入到当前线程中，合并为一个线程，由两个线程交替执行变成一个线程中的两个子线程顺序执行，通过调用 join 方法实现合并。

```java
package com.southwind.demo3;

public class Test2 {
    public static void main(String[] args) {
        Thread thread = new Thread(()->{
            for (int i = 0; i < 20; i++) {
                System.out.println(i + "----------------JoninRunnable");
            }
        });
        thread.start();
        for (int i = 0; i < 100; i++) {
            if(i == 10){
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(i + "+++++++++++++++++++++++++main");
        }
    }
}
```

join 的使用方法：线程甲和线程乙，线程甲在执行到某个时间点的时候，调用线程乙的 join 方法，则表示从当前时间结点开始，CPU 资源被线程乙独占，线程甲就进入阻塞状态，直到线程乙执行完毕，线程甲进入就绪状态，等待获取 CPU 资源继续执行。

join 方法存在重载，无参数的 join 指的是线程乙抢占 CPU 资源之后，直到任务全部完成，才会释放 CPU 资源。

join(final long millis) 指线程乙抢占 CPU 资源之后，millis 毫秒之后，无论释放执行完毕，都会释放 CPU 资源，两个线程重新去争夺资源。

join(long millis, int nanos) 指线程乙抢占 CPU 资源之后，millis 毫秒 + nanos 纳秒之后，无论释放执行完毕，都会释放 CPU 资源，两个线程重新去争夺资源。

#### 3.3 线程礼让

线程礼让是指在某个时间点，让线程暂停抢占 CPU 资源，从运行状态或者就绪状态来到阻塞状态，从而将 CPU 资源让给其他线程来使用，程序中的线程礼让通过调用 yield 方法实现。

```java
package com.southwind.demo3;

public class Test3 {
    public static void main(String[] args) {
        //线程1
        new Thread(()->{
            for (int i = 0; i < 100; i++) {
                if(i == 33){
                    Thread.yield();
                }
                System.out.println(Thread.currentThread().getName() + "---" + i);
            }
        },"张三").start();
        //线程2
        new Thread(()->{
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + "---" + i);
            }
        },"李四").start();
    }
}
```

#### 3.4 线程中断

Java 主动终端线程常用方法：

- public void stop()
- public viod interrupt()
- public boolean isInterrupted()

每个线程对象都是通过一个标志位来判断当前是否为中断状态，isInterrupted 就是用来获取当前线程对象的标志位。true 表示清除了标志位，当前线程对象已经中断；false 表示没有清除标志位，当前线程对象没有中断。

```java
package com.southwind.demo3;

public class Test5 {
    public static void main(String[] args) {
        Thread thread = new Thread();
        System.out.println(thread.getState());
        thread.start();
        System.out.println(thread.getState());
        thread.interrupt();
        System.out.println(thread.isInterrupted());
    }
}
```

### 4. 线程同步

#### 4.1 线程同步的实现

通过 synchronized 关键字实现线程同步，解决数据错误的问题。

每个 Java 对象都有一个内置锁，内置锁会保护使用 synchronized 修饰的方法，要调用该方法必须先获取内置锁，否则一直处于阻塞状态。

```java
package com.southwind.demo4;

public class Test {
    public static void main(String[] args) {
        Account account = new Account();
        new Thread(account,"张三").start();
        new Thread(account,"李四").start();
    }
}

class Account implements Runnable{
    private static int num;
    @Override
    public synchronized void run() {
        num++;
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "是当前第" + num + "位访客");
    }
}
```

synchronized 可以修饰实例方法，也可以修饰静态方法。

同步就是指让多线程按顺序排队完成任务，异步指多个线程同时执行。

```java
package com.southwind.demo4;

public class Test2 {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            new Thread(()->{
                test();
            }).start();
        }
    }

    public synchronized static void test(){
        System.out.println("start...");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("end...");
    }
}
```

synchronized 除了可以修饰方法之外，还可以直接修饰代码块，为代码块加上内置锁，从而实现同步。

static 方法中修饰代码块

```java
package com.southwind.demo4;

public class Test3 {

    private static String name = "Hello";

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            Integer num = 1;
            num++;
            final Integer num2 = num;
            new Thread(()->{
                test(num2);
            }).start();
        }
    }

    public static void test(Integer num){
        //只能锁对象
        synchronized (num){
            System.out.println("start...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("end...");
        }
    }
}
```

实例方法中修饰代码块

```java
package com.southwind.demo4;

public class Test4 {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            Integer num = 1;
            num++;
            final Integer num2 = num;
            //lambda 中的参数必须是常量
            new Thread(()->{
                Test4 test4 = new Test4();
                test4.test(num2);
            }).start();
        }
    }

    public void test(Integer num){
        synchronized (num){
            System.out.println("start...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("end...");
        }
    }
}
```

synchronized 线程同步是面试中的一个高频考点，只要掌握本质，就不怕题型的改变，本质是什么？

看锁定的是否为共享数据（多线程共享）

如果修饰方法，静态方法可以同步，实例方法的话由实例对象的个数来决定。

如果修饰代码块，由 synchronized()  锁定的对象来决定，看这个对象是共享还是不共享的。

同时有多个对象的前提下，如果是包装类对象，只要值是相等的就认为是共享的，如果是其他类型的对象，则不共享。

#### 4.2 线程安全的单例模式

单例（Singleton）模式是一种常见的软件设计模式，核心思想是一个类只能有一个实例化对象，由多个线程共享该实例对象资源。

```java
package com.southwind.demo5;

public class SingletonDemo {
    private SingletonDemo(){
        System.out.println("创建了SingletonDemo");
    }

    private static SingletonDemo instance = null;

    //加锁方法
    public synchronized static SingletonDemo getInstance(){
        if(instance == null){
            instance = new SingletonDemo();
        }
        return instance;
    }
}
```

```java
package com.southwind.demo1;

public class SingletonDemo {
    //volatile 使内存中的数据对线程可见
    private volatile static SingletonDemo singletonDemo;

    private SingletonDemo(){
        System.out.println("创建了SingletonDemo对象");
    }

    //double check 双重检测
    public static SingletonDemo getInstance(){
        if(singletonDemo == null){
            //加锁代码块
            synchronized (SingletonDemo.class){
                if(singletonDemo == null){
                    singletonDemo = new SingletonDemo();
                }
            }
        }
        return singletonDemo;
    }

}
```

volatile 的作用是可以使内存中的数据对线程可见。

JMM Java Memory Model

一个线程在访问某个的数据的时候，并不会拿到数据本身，而是将该数据复制保存到工作内存中，相当于取出一个副本，线程对工作内存中的数据进行修改，再保存到主内存中，即主内存对线程是不可见的。

![image-20200625002408595](C:\Users\userhan\AppData\Roaming\Typora\typora-user-images\image-20200625002408595.png)

### 5. 死锁

使用 synchronized 关键字实现线程同步的同时也会带来一个隐患，是比较严重的，就是死锁。

如何解决死锁？

只要有一个线程愿意做出让步，贡献出自己的资源给其他线程使用，其他线程就可以执行自己的任务，执行完毕之后就会自然释放所有的资源，给另外一个线程使用，这样所有的线程都可以完成自己的任务了。

```java
package com.southwind.demo2;

public class Chopsticks {

}
```

```java
package com.southwind.demo2;

public class DeadLockRunnable implements Runnable {
    public int num;
    private static Chopsticks chopsticks1 = new Chopsticks();
    private static Chopsticks chopsticks2 = new Chopsticks();
    @Override
    public void run() {
        if(num == 1){
            System.out.println(Thread.currentThread().getName() + "获取了chopsticks1，等待获取chopsticks2");
            synchronized (chopsticks1){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (chopsticks2){
                    System.out.println(Thread.currentThread().getName() + "用餐完毕");
                }
            }
        }

        if(num == 2){
            System.out.println(Thread.currentThread().getName() + "获取了chopsticks2，等待获取chopsticks1");
            synchronized (chopsticks2){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (chopsticks1){
                    System.out.println(Thread.currentThread().getName() + "用餐完毕");
                }
            }
        }
    }
}
```

```java
package com.southwind.demo2;

public class Test {
    public static void main(String[] args) {
        DeadLockRunnable deadLockRunnable1 = new DeadLockRunnable();
        deadLockRunnable1.num = 1;
        DeadLockRunnable deadLockRunnable2 = new DeadLockRunnable();
        deadLockRunnable2.num = 2;
        new Thread(deadLockRunnable1,"张三").start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(deadLockRunnable2,"李四").start();
    }
}
```

### 6. 生产者消费者模式

消息中间件 MQ 消息队列 异步解耦、流量削峰

RocketMQ 亿万级流量

在一个生产环境中，生产者和消费者共享同一块缓冲区，生成者负责向缓冲区中添加数据，消费者负责从缓冲区中取出数据进行消费。

以生成汉堡和消费汉堡为例实现生产者消费者模式。

```java
package com.southwind.demo3;

/**
 * 汉堡类
 */
public class Hamburger {
    private int id;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public Hamburger(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "Hamburger{" +
                "id=" + id +
                '}';
    }
}
```

```java
package com.southwind.demo3;

/**
 * 装汉堡的容器
 */
public class Container {
    public Hamburger[] array = new Hamburger[6];
    public int index = 0;
    //向容器中添加汉堡
    public synchronized void push(Hamburger hamburger){
        while (index == array.length){
            try {
                //让当前线程休眠
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //唤醒休眠的线程
        this.notify();
        array[index] = hamburger;
        index++;
        System.out.println("生产了一个汉堡：" + hamburger);
    }
    //从容器中取出汉堡
    public synchronized Hamburger pop(){
        while (index == 0){
            try {
                //让当前线程休眠
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        this.notify();
        index--;
        System.out.println("消费了一个汉堡：" + array[index]);
        return array[index];
    }
}
```

```java
package com.southwind.demo3;

/**
 * 生产者
 */
public class Producer implements Runnable {
    private Container container;

    public Producer(Container container) {
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 30; i++) {
            Hamburger hamburger = new Hamburger(i);
            this.container.push(hamburger);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
package com.southwind.demo3;

/**
 * 消费者
 */
public class Consumer implements Runnable {
    private Container container;

    public Consumer(Container container) {
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 30; i++) {
            this.container.pop();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
package com.southwind.demo3;

public class Test {
    public static void main(String[] args) {
        //装汉堡的容器
        Container container = new Container();
        //生产任务
        Producer producer = new Producer(container);
        //消费任务
        Consumer consumer = new Consumer(container);
        //两个生产者+两个消费者
        new Thread(producer).start();
        new Thread(producer).start();
        new Thread(consumer).start();
        new Thread(consumer).start();
    }
}
```

wait sleep 的区别：

- wait 方法是由 Object 提供的，作用于资源，让正在访问当前资源的线程休眠。
- sleep 方法是由 Thread 提供的，作用于线程，让当前线程休眠。

### 7. Java 并发编程

为什么并发编程如此重要？

并发编程可以提升计算机的效率，将计算机的性能发挥到最大，可以节约成本。

#### 7.1 什么是高并发？

并行和并发的区别

并发 concurrency、并行 parallelism

> 并发是指多个线程操作同一个资源，但不是同时操作，是交替操作，单核 CPU 的情况下，资源按时间段分配给多个线程。

> 并行才是真正的多个线程同时执行，多核 CPU，每个线程使用一个 CPU 的资源来运行。

```java
System.out.println(Runtime.getRuntime().availableProcessors());
```

我们所说的并发编程描述的是一种使系统允许多个任务在重叠的时间内同时执行的设计结构。

并发并不是指多个任务同时执行，而是指系统具备同时处理多个任务的能力。

高并发就是指我们设计的程序，可以支持海量任务的执行在时间段上重叠的情况。

High Concurrency 是互联网分布式系统架构设计中必须要考虑的因素之一，同时设计保证系统能够同时处理多个请求。

高并发的标准：

1、QPS：每秒响应的 HTTP 请求数。

2、吞吐量：单位时间内处理的请求，由 QPS 和并发数决定的。

3、平均响应时间：系统对一个请求做出响应的平均时间。

QPS = 并发数 / 平均响应时间

4、并发用户数：同时承载能够正常使用系统的用户数量。

互联网分布式架构中，提高系统并发能力的方式，主要有两种：

- 垂直扩展
- 水平扩展

#### 7.2 垂直扩展

提升单机处理能力，垂直扩展又可以分为两个方式：

1、增强单机硬件配置。

2、提升单机的架构能力：使用 Cache 来提高效率，使用 NoSQL 提升数据访问能力。

#### 7.3 水平扩展

集群和分布式都是水平扩展的方案。

饭店，一个厨师炒菜，需求量突增，一个厨师无法完成需求，集群就是同时雇佣 3 个厨师炒菜。

分布式是指把炒菜的过程拆分成多个步骤：1、洗菜 2、切菜 3、炒菜

还是一个厨师，给他雇佣两个助手，一个助手负责洗菜，一个助手负责切成，厨师只负责炒菜。

### 8. synchronized 锁定对象

#### 8.1 非静态方法

如果 synchronized 修饰非静态方法，则锁定的是方法的调用者。

```java
package com.southwind.demo6;

import java.util.concurrent.TimeUnit;

public class Test {
    public static void main(String[] args) {
        //1、2
        Data data = new Data();
        new Thread(()->{
            data.func1();
        },"A").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            data.func2();
        },"B").start();
    }
}

class Data{
    public synchronized void func1(){
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("1...");
    }

    public synchronized void func2(){
        System.out.println("2...");
    }
}
```

线程 A 锁定 data，等待 3 秒之后输出 1...，任务结束，这期间线程 B 一直处于阻塞状态，直到线程 A 执行完毕释放锁之后，线程 B 立即执行。

```java
package com.southwind.demo6;

import java.util.concurrent.TimeUnit;

public class Test {
    public static void main(String[] args) {
        Data data1 = new Data();
        Data data2 = new Data();
        new Thread(()->{
            data1.func1();
        },"A").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            data2.func2();
        },"B").start();
    }
}

class Data{
    public synchronized void func1(){
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("1...");
    }

    public synchronized void func2(){
        System.out.println("2...");
    }
}
```

此时先输出 2 再输出 1

```java
package com.southwind.demo6;

import java.util.concurrent.TimeUnit;

public class Test {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(()->{
            data.func1();
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            data.func3();
        }).start();
    }
}

class Data{
    public synchronized void func1(){
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("1...");
    }

    public synchronized void func2(){
        System.out.println("2...");
    }

    public void func3(){
        System.out.println("3...");
    }
}
```

先输出 3 再输出 1

#### 8.2 静态方法

如果 synchronized 修饰的是静态方法，则锁定的是类，无论多少个对象调用，都会同步

```java
package com.southwind.demo7;

import java.util.concurrent.TimeUnit;

public class Test {
    // 1 2
    public static void main(String[] args) {
        Data data1 = new Data();
        Data data2 = new Data();
        new Thread(()->{
            data1.func1();
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            data2.func2();
        }).start();
    }
}

class Data{
    public synchronized static void func1(){
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("1...");
    }

    public synchronized static void func2(){
        System.out.println("2...");
    }
}
```

> 如果 synchronized 静态方法和 synchronized 实例方法同时存在，静态方法锁的是类，实例方法锁的是对象，两者互不干扰

```java
package com.southwind.demo8;

import java.util.concurrent.TimeUnit;

public class Test {
    public static void main(String[] args) {
        Data data1 = new Data();
        Data data2 = new Data();
        new Thread(()->{
            data1.func1();
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            data2.func2();
        }).start();
    }
}

class Data{
    public synchronized static void func1(){
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("1...");
    }

    public synchronized void func2(){
        System.out.println("2...");
    }
}
```

#### 8.3 代码块

如果 synchronized 修饰的是代码块，则锁定的是传入的对象

```java
package com.study13.demo7;

import java.util.concurrent.TimeUnit;

public class Test {
    public static void main(String[] args) {
        Data data = new Data();
        Data data1 = new Data();
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                data.func(1);
            },"A").start();
        }

        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                data1.func(1);
            },"B").start();
        }
    }
}

class Data{
    public void func(Integer num) {
        synchronized(num) {
            System.out.println(Thread.currentThread().getName());
            System.out.println("start...");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName());
            System.out.println("...end");
        }
    }
}

```

### 9. Lock

#### 9.1 简介

Lock（锁）是对 synchronized 的升级，JUC 提供的一个接口，实现上锁机制的，它的常用实现类是 ReentrantLock（重入锁）。

synchronized 是通过 JVM 实现的，Lock 是通过 JDK 实现。

重入锁有什么特点呢？重入锁指可以给同一个资源添加多个锁，并且解锁的方式与 synchronized 完全不同。

synchronized 的锁是线程执行完毕之后自动释放，Lock 的锁必须手动释放。

```java
package com.study13.demo8;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test {
    public static void main(String[] args) {
        Ticker ticker = new Ticker();
        new Thread(()->{
            for (int i = 0; i < 40; i++) {
                ticker.sale();
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 40; i++) {
                ticker.sale();
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0; i < 40; i++) {
                ticker.sale();
            }
        },"C").start();
    }
}

class Ticker{
    private int lastNUm = 31;
    private int saleNum = 0;
    Lock lock = new ReentrantLock();
    public void sale() {

        while (lastNUm == 0) {
            return;
        }

        while (lastNUm > 0) {
//            try {
//                TimeUnit.SECONDS.sleep(1);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
            lock.lock();
            while (lastNUm == 0) {
                return;
            }
            lastNUm--;
            saleNum++;
            System.out.println("窗口"+Thread.currentThread().getName()+"当前售出"+saleNum+"剩余"+lastNUm);
            lock.unlock();
        }

    }
}
```

#### 9.2 synchronized 和 Lock的区别

1、synchronized 自动上锁，自动释放锁，Lock 手动上锁，手动释放锁。

2、synchronized 无法判断是否获取到锁，Lock 可以判断是否拿到了锁。

3、synchronized 拿不到锁就会一直等待，Lock 不一定会等待。

4、synchronized 是 Java 关键字，JVM 实现，Lock 是一个接口，JDK 实现。

5、synchronized 是非公平锁，Lock 可以设置是否为公平锁。

公平锁：排队，当锁状态没有被占用的时候，当前要获取锁的线程要判断等待队列中是否有其他等待线程。

非公平锁：插队，当锁状态没有被占用的时候，当前线程可以直接占用，不需要判断队列中是否有其他等待线程。

Lock 常用的实现类是 ReentrantLock，它除了可重入之外，还有一个可中断的特点：允许在某个线程等待的时候，由其他线程调用等待线程的 Thread.interrupt 方法来中断等待线程，此时不需要获取锁，而会抛出异常 InterruptedException，通过调用 lockInterruptibly 来实现，不需要获取锁，可以直接中断。

```java
public class Test {
    public static void main(String[] args) throws Exception {
        Lock lock = new ReentrantLock();
        lock.lock();
        Thread thread = new Thread(()->{
            try {
                lock.lockInterruptibly();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "interrupted");
        });
        thread.start();
        TimeUnit.SECONDS.sleep(1);
        thread.interrupt();
    }
}
```

ReentrantLock 还具备限时性的特点，可以判断某个线程在一定时间内能否获取到锁，使用 tryLock 方法，返回值是 boolean，true 表示在该时间段内获取了锁，false 表示在该时间段内没有获取锁。

```java
package com.southwind.demo1;

import com.sun.source.doctree.ThrowsTree;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test2 {
    public static void main(String[] args) {
        TimeLock timeLock = new TimeLock();
        new Thread(()->{
            timeLock.getLock();
        },"A").start();

        new Thread(()->{
            timeLock.getLock();
        },"B").start();
    }
}

class TimeLock{
    private ReentrantLock lock = new ReentrantLock();
    public void getLock() {
        try {
            if(lock.tryLock(6, TimeUnit.SECONDS)){
                System.out.println(Thread.currentThread().getName() + "拿到了锁");
                TimeUnit.SECONDS.sleep(5);
            }else{
                System.out.println(Thread.currentThread().getName() + "没有拿到锁");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            if(lock.isHeldByCurrentThread()){
                lock.unlock();
            }
        }
    }
}
```

#### 9.3 生产者消费者模式

##### 9.3.1 synchronized 版

```java
package com.study14.demo2;

import java.util.concurrent.TimeUnit;

public class ProviderConsumerTest {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(()->{
            for (int i = 0; i < 30; i++) {
                data.increment();
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 30; i++) {
                data.decrement();
            }
        },"B").start();
    }
}

class Data{
    private Integer num = 0;

    /***
     * 生产
     */
    public synchronized void increment() {
        while (num != 0) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        num++;
        this.notify();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+num);
    }

    /***
     * 消费
     */
    public synchronized void decrement() {
        while (num != 1) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        num--;
        this.notify();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+num);
    }
}




```

##### 9.3.2 Lock 版

```java
package com.southwind.demo2;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProdiverConsumerLockTest {

    public static void main(String[] args) {
        Data2 data2 = new Data2();
        new Thread(()->{
            for (int i = 0; i < 30; i++) {
                data2.increment();
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 30; i++) {
                data2.decrement();
            }
        },"B").start();
    }

}

class Data2{
    private Integer num = 0;
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    public void increment(){
        try {
            lock.lock();
            while(num != 0){
                //this.wait()
                condition.await();
            }
            num++;
            //this.notify()
            condition.signal();
            System.out.println(Thread.currentThread().getName() + "--->" + num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void decrement(){
        try {
            lock.lock();
            while(num == 0){
                condition.await();
            }
            num--;
            condition.signal();
            System.out.println(Thread.currentThread().getName() + "--->" + num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

### 10. ConcurrentModificationException 并发修改异常

```java
public class Test {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                list.add("a");
                System.out.println(list);
            }).start();
        }
    }
}
```

ArrayList 是线程不安全的，多线程并发访问会导致数据错误。

解决办法：

1、将 ArrayList 替换成线程安全的 Vetor。

ArrayList 的 add 方法线程不安全

```java
public boolean add(E e) {
    modCount++;
    add(e, elementData, size);
    return true;
}
```

Vetor 的 add 方法线程安全

```java
public synchronized boolean add(E e) {
    modCount++;
    add(e, elementData, elementCount);
    return true;
}
```

2、使用 Collections.synchronizedList

```java
public class Test {
    public static void main(String[] args) {
        List<String> list = Collections.synchronizedList(new ArrayList<>());
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                list.add("a");
                System.out.println(list);
            }).start();
        }
    }
}
```

3、JUC CopyOnWriteArrayList

```java
public class Test {
    public static void main(String[] args) {
        List<String> list = new CopyOnWriteArrayList<>();
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                list.add("a");
                System.out.println(list);
            }).start();
        }
    }
}
```

CopyOnWriteArrayList，CopyOnWrite 写时复制，当我们往一个容器中添加元素的时候，不直接往当前容器中添加，而是先将当前容器进行 Copy，复制出一个新的容器，往新的容器中添加数据，添加完成之后，再将原容器的引用指向新的容器。

```java
//获取容器
Object[] es = getArray();
//获取容器的长度
int len = es.length;
//复制容器，长度+1
es = Arrays.copyOf(es, len + 1);
//在容器的末尾添加新元素
es[len] = e;
//返回新的容器
setArray(es);
```

要实现读写分离

### 11. JUC工具类

#### 11.1 CountDownLatch：减法计数器

JUC 提供的一个工具类，可以用来倒计时，当两个线程同时执行时，如果我们要确保一个线程优先执行，就可以使用计数器，当计数器清零的时候，另外一个线程再执行。

```java
package com.southwind.demo4;

import java.util.concurrent.CountDownLatch;

public class CountDownLatchTest {
    public static void main(String[] args) {

        CountDownLatch countDownLatch = new CountDownLatch(100);

        new Thread(()->{
            for (int i = 0; i < 100; i++) {
                System.out.println("+++++++++++++++++++Thread");
                countDownLatch.countDown();
            }
        }).start();

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for (int i = 0; i < 100; i++) {
            System.out.println("main--------------------");
        }
    }
}
```

countDown 计数器减一

await 计数器停止，唤醒其他线程

new CountDownLatch(100)、coutDown()、await() 必须配合使用，创建对象的时候赋的值是多少，countDown() 必须执行多少次，否则计数器无法清零，计数器不停止，其他线程无法唤醒，所以我们必须保证计数器可以清零，coutDown() 的调用次数必须大于构造函数的值。

#### 11.2 CyclicBarrier 加法计数器

```java
package com.southwind.demo1;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierTest {
    public static void main(String[] args) {
        //创建加法计数器对象
        CyclicBarrier cyclicBarrier = new CyclicBarrier(30,()->{
            System.out.println("旅游");
        });

        for (int i = 0; i < 90; i++) {
            final int temp = i;
            new Thread(()->{
                System.out.println("---" + temp);
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

await：在其他线程中试图唤醒计数器，当其他线程的执行次数达到计数器的临界值，则唤醒计数器，并且计数器是可以重复使用的，当计数器的线程执行完成一次之后，计数器自动清零。

#### 11.3 Semaphore 计数信号量

实际开发中主要是用来完成限流操作的

限流：限制流量（高并发请求），限制访问某些资源的线程数量。

新开一家乐高店，人非常多，店家就需要施行限流操作，一次只放一定数量的客人进店，等这批客人陆续出店之后，再放下一批客人进店。

```java
package com.southwind.demo1;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class SemaphoreTest {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(5);
        for (int i = 0; i < 15; i++) {
            new Thread(()->{
                try {
                    //获得许可
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "进店购物");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName() + "出店");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    //释放许可
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

#### 11.4 读写锁

接口 ReadWriteLock，实现类是 ReentrantReadWriteLock，可以多线程同时读，但是同一时间内只能有一个线程进行写入。

粒度更细的一种线程同步，可以同时给读（共享锁）和写（独占锁）设置不同的同步机制。

```java
package com.southwind.demo1;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockTest {
    public static void main(String[] args) {
        Cache cache = new Cache();
        for (int i = 0; i < 5; i++) {
            final int temp = i;
            new Thread(()->{
                cache.write(temp,String.valueOf(temp));
            }).start();
        }

        for (int i = 0; i < 5; i++) {
            final int temp = i;
            new Thread(()->{
                cache.read(temp);
            }).start();
        }
    }
}

/**
 * 同一时间段内有多个线程在读，但是只有一个线程在写
 */
class Cache{
    private Map<Integer,String> map = new HashMap<>();
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    /**
     * 写
     */
    public void write(Integer key,String value){
        readWriteLock.writeLock().lock();
        System.out.println(key+"开始写入");
        map.put(key,value);
        System.out.println(key+"写入完毕");
        readWriteLock.writeLock().unlock();
    }

    /**
     * 读
     */
    public void read(Integer key){
        readWriteLock.readLock().lock();
        System.out.println(key+"开始读取");
        map.get(key);
        System.out.println(key+"读取完毕");
        readWriteLock.readLock().unlock();
    }
}
```

### 12. 线程池

“池化思想”：提高代码的利用率，合理利用资源，提高系统的性能。

预先创建好一定数量的线程对象，存入缓冲池中，需要用的时候直接从缓冲池中取出，用完之后不要销毁，还原到缓冲池中，供下一次任务使用，重复利用线程对象，提高利用率。

优势：

- 提高线程的利用率
- 提高响应速度
- 便于统一管理线程对象
- 可控制最大并发数

#### 12.1 7大参数

- corePoolSize：核心池的大小，初始化线程数。
- maxinumPoolSize：最大线程数，线程池可以扩充的最大上限。
- keepAliveTime：线程存活时间，线程没有执行任务的情况下可以存活的时间。
- unit：存活时间的单位，7 种取值

```
TimeUnit.DAYS
TimeUnit.HOURS
TimeUnit.MINUTES
TimeUnit.SECONDS
TimeUnit.MILLISECONDS
TimeUnit.MICOSECONDS
TimeUnit.NANOSECODS
```

- wrokQueue：阻塞队列，用来存储等待执行的任务。
- threadFactory：线程工厂，用来创建线程对象。
- handler：拒绝策略

```
ThreadPoolExecutor.AbortPolicy
ThreadPoolExecutor.DiscardPolicy
ThreadPoolExecutor.DiscardOldestPolicy
ThreadPoolExecutor.CallerRunPolicy
```

简化的方式

```java
package com.southwind.demo1;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 10; i++) {
            final int temp = i;
            executorService.execute(()->{
                System.out.println(Thread.currentThread().getName() + ":" + temp);
            });
        }
        executorService.shutdown();
    }
}
```

#### 12.2 三种简单创建方式

线程池的具体使用（3 种实现）

```java
package com.southwind.demo1;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Test {
    public static void main(String[] args) {
        //创建线程池(单例：只有一个线程对象)
//        ExecutorService executorService = Executors.newSingleThreadExecutor();
        //固定线程数量的线程池
//        ExecutorService executorService = Executors.newFixedThreadPool(20);
        //缓存线程池，随机，由当前电脑配置决定
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 500; i++) {
            final int temp = i;
            executorService.execute(()->{
                System.out.println(Thread.currentThread().getName() + ":" + temp);
            });
        }
        executorService.shutdown();
    }
}
```

Executors.newSingleThreadExecutor()：线程池中只有一个线程实例

Executors.newFixedThreadPool(20)：线程池中有固定的 20 个线程实例

Executors.newCachedThreadPool()：线程池中的线程实例数量随机，由电脑配置决定（配置越高，数量越大）

以上 3 种方式是最基本的使用线程池的方式，用的是 JUC 提供好的封装，使用简单但是功能有局限，实际开发中一般不使用这种方式，直接使用原生的线程池创建方式。

#### 12.3 手动创建

手动创建一个线程池 corePoolSize = 3，maxinumPoolSize = 5，workQueue = 3

```java
package com.southwind.demo1;

import java.util.concurrent.*;

public class Test2 {

    public static void main(String[] args) {
        //手动创建线程池
        ExecutorService executorService = new ThreadPoolExecutor(
                3,
                5,
                1L,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        for (int i = 0; i < 9; i++) {
            executorService.execute(()->{
                try {
                    TimeUnit.MILLISECONDS.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "===>办理业务");
            });
        }
        executorService.shutdown();
    }
}
```

当任务量超过线程池的可容纳的最大上限（最大线程数+等待队列的长度），再来新的任务就直接拒绝，4 种拒绝方式：

- AbortPolicy 抛出异常
- CallerRunsPolicy 谁调用谁处理
- DiscardOldestPolicy 尝试与阻塞队列最前面的任务争夺，不抛出异常
- DiscardPolicy 放弃任务，不抛出异常

线程池 3 大考点：

- 3 种基本实现
- 7 大参数
- 4 大拒绝策略

### 13. ForkJoin框架

ForkJoin JDK 1.7 之后提供的多线程并发处理框架，本质上就是对线程池的一种补充，它的核心思想就是将一个大型任务拆分成多个小任务，分别执行，最终将小任务的结果再进行汇总即可。

![image-20200701073737109](C:\Users\userhan\AppData\Roaming\Typora\typora-user-images\image-20200701073737109.png)

就是将一个线程拆分成多个线程并发执行

比如 A B 两个线程同时执行，A 的任务比较多，B 先执行完了，这时候 B 就会将 A 的一部分任务拿过来替 A 执行，从而提升效率。

**工作窃取**，ForkJoin 会把任务进行拆分，拆分之后的子任务会添加到当前工作线程双端队列的头部，当一个工作线程没有任务时，会从其他工作线程队列的尾部获取一个任务。

![image-20200701073751808](C:\Users\userhan\AppData\Roaming\Typora\typora-user-images\image-20200701073751808.png)

使用 ForkJoin 框架，需要用到两个类 ForkJoinTask 和 ForkJoinPool

- ForkJoinTask 是用来描述任务的。
- ForkJoinPool 是提供多线程并发工作窃取的，它是对线程池的一种扩展。

使用 ForkJoinTask 最重要的就是搞清楚如何去拆分任务，使用的是递归的思想。

### 14. 递归

是一种程序开发种使用非常广泛的一种算法，比如深度优先搜索、二叉树遍历。

什么是递归？

编程语言种，函数function，直接或间接调用函数本身，则该函数就是递归函数。

自己调自己。

电影院看电影，不知道自己是第几排，问前排，前排也不知道，继续问他的前排，依次类推，直到问到第一排，开始依次向后返回结果，一排排传递，最终回归到问题的出发点。

去的过程叫做“递”，回来的过程叫做“归”。

用递推公式表示

```
f(n) = f(n-1)+1,f(1) = 1
```

写代码

```java
int f(int n){
    if(n==1) return 1;
	return f(n-1)+1;
}
```

递归需要满足 3 要素：

1、一个父问题开源拆分成若干个子问题，并且若干个子问题的结果汇总起来就是父问题的结果。

2、父问题和子问题，解题思路完全一致，只是数据规模不同。

3、存在终止条件，问题在不断拆分的同时，一定要在某个节点终止拆分，得到一个明确的答案。

有 n 个台阶，每次可以跨 1 个台阶或者 2 个台阶，n 个台阶一共有多少种走法？

1、假设有 1 个台阶，1 种走法

2、假设有 2 个台阶，2 种走法【1，1】【2】

3、假设有 3 个台阶，3 种走法 【1，1，1】【1，2】【2，1】

...

n

可以根据第一步的走法将所有的走法分为两类

- 第一步走了 1 个台阶
- 第一步走了 2 个台阶

所以 n 个台阶的走法就等于，（先走 1 个台阶，n-1 个台阶的走法）+（先走 2 个台阶，n-2 个台阶的走法）

得出公式

```
f(n) = f(n-1)+f(n-2)
```

有了递推公式之后，接下来寻找终止条件，

只有一个台阶的时候，就不需要递归，只有一种走法，f(1) = 1

假设 n = 2，f(2) = f(1)+f(0) = 1+f(0)，f(0) 的值必须确定，这样 f(2) 的值才能确定，但是 f(0) 的值是不存在的，怎么办？f(2) 确定即可，f(2) = 2

所以终止条件 f(1) = 1,f(2) = 2

```
f(n) = f(n-1)+f(n-2);
f(1) = 1;
f(2) = 2;
```

```java
public static int f(int n){
    if(n == 1) return 1;
    if(n == 2) return 2;
    return f(n-1)+f(n-2);
}
```

#### 14.1 ForkJoin 如何使用

1、创建 ForkJoinTask 任务。

2、任务要通过 ForkJoinPool 来执行。

计算 0-20 亿数字之和。

常规写法，直接循环

![image-20200701073939740](C:\Users\userhan\AppData\Roaming\Typora\typora-user-images\image-20200701073939740.png)

```java
package com.southwind.demo2;

import java.util.concurrent.RecursiveTask;

public class ForkJoinDemo extends RecursiveTask<Long> {
    private Long start;
    private Long end;
    private Long temp = 100_0000L;

    public ForkJoinDemo(Long start,Long end){
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if((end - start)<temp){
            Long sum = 0L;
            for (Long i = start;i<=end;i++){
                sum += i;
            }
            return sum;
        }else{
            Long avg = (start+end)/2;
            ForkJoinDemo task1 = new ForkJoinDemo(start,avg);
            task1.fork();
            ForkJoinDemo task2 = new ForkJoinDemo(avg+1,end);
            task2.fork();
            return task1.join()+task2.join();
        }
    }
}
```



```java
package com.southwind.demo2;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;

public class Test {
    public static void main(String[] args) {
        Long startTime = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask<Long> task = new ForkJoinDemo(0L,20_0000_0000L);
        forkJoinPool.execute(task);
        Long sum = 0L;
        try {
            sum = task.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        Long endTime = System.currentTimeMillis();
        System.out.println(sum + ",共耗时:" + (endTime - startTime));
    }
}
```

### 15. Volatile 关键字 

volatile 是 JVM 提供的轻量级同步机制，它的作用是让主内存对线程可见，一般应用在单例模式的代码中。

```java
package com.southwind.demo3;

import java.util.concurrent.TimeUnit;

public class Test2 {
    private static int num = 0;
    public static void main(String[] args) {
        new Thread(()->{
            while (num == 0){
                System.out.println("---Thread");
            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        num = 1;
        System.out.println(num);
    }
}
```

循环体为空，子线程无法感知到 num 的改变，但是有输出语句就能感知到吗，为啥？

不添加 volatile 关键字的时候，Java 内存模型，一个线程执行完任务之后，**会从主内存中读取当前的值**。
