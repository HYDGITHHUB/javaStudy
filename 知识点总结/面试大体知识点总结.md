## Java基础

### JVM （Hot_Spot）

#### 1. 类初始化过程

#### 2. 类加载器

#### 3. JVM 虚拟机

#### 4. JVM 优化

#### 5. 程序执行过程







>JVM 调优
>
>类加载过程
>
>Java运行时内存分区
>
>内存模型
>
>怎么使方法区满，栈，堆满
>
>垃圾回收机制 CMS G1
>
>类加载机制，链接
>
>JVM内存结构
>
>堆，栈，方法区
>
>GC
>
>可以创建多个线程吗
>
>创建对象，赋值等操作的具体内存变化，指针碰撞，空闲列表
>
>栈内存，堆内存，方法区（OOM）内存溢出
>
>类加载机制是在 生成 .class文件之前还是之后
>
>Java 中 JVM入栈具体操作
>
>对象实例化过程

### 关系型数据库

#### 1. MySQL

##### 1. 索引结构

###### 1.0 为什么有索引

>当没有索引的时候，需要查找数据的话需要遍历整张表知道找到相应的数据，需要进行很多次的磁盘 IO，是既浪费时间，又对磁盘有所损耗的。

###### 1. 1 为什么不用 Hash 索引

（索引：帮助 MySQL 高效获取数据的排好序的数据结构）

> 
>
> Hash 值是无序的，所以无法进行范围查找。
>
> 有些数不相同，但是其 Hash 值是相同的。

###### 1.2 为什么 平衡二叉树（红黑树）不可以

（红黑树不是绝对的平衡二叉树，平衡二叉树要求左右树的高度差为1，二红黑树仅仅要求左右的黑节点数目一样即可，即左右相差二倍以内即可。）

> 树的高度随着插入数值的增加增加，导致查询的代价变大。尤其是大数据。
>
> 进行范围查找的话，需要先查找到相应的数，然后再往回遍历，代价较大。

###### 1.3 为什么不选择 B 树

>利用某个节点数不仅仅为 1 的特点，一定程度上降低了数的高度
>
>还是存在回旋查找的问题。

###### 1.4 为什么不选 二叉树

> 比平衡二叉树还差的是：如果是单调递增或递减的，即使建立索引的话，遍历次数也和没有建立索引一样。

###### 1.5 为什么使用 B+ （多叉平衡树）树

>每个节点设置大小为 16 KB，我们设置主键一般为 BigInt，为 8 个字节，每个非叶子节点左右对应的下一级索引占 6 个字节（每个节点不可以设置的过大，不然加载到内存中的话太过消耗内存）（每非叶子个节点近乎可以存放 （16KB /(8b+6b）= 1170 ) 个索引，高度为3 的 B+ 树差不多可以放（1170 * 1170 * 16） 近乎两千万的数据，叶子节点因为要存放对应索引的内存地址或者数据，算作较大为 1 KB。
>
>****
>
>和 B 树区别：
>
>叶子节点是排好序的，并且有指向下一节点的双向区间指针（单向链表），而且其中携带该索引的信息（内存地址）。
>
>B 树中每个节点都携带有其数据，而 B+ 树中只有非叶子结点携带数据。
>
>好处：在相同大小的情况下，B+ 树存储的数据量远远大于 B 树。
>
>****
>
>首先将整个根节点加载到内存中（一般常驻内存），然后根据比对（每个节点左右有其下一级节点的内存信息），将相应的下一级节点加载到内存中。
>
>

##### 2. 存储引擎

是用来形容数据库**表**的，主要 InnoDB 和 MyISAM

###### 2.1 MyISAM 

>.frm 文件：表的结构，数据类型之类的
>
>.MYD文件：表的数据
>
>.MYI：表的索引，B+ 树的结构，稀疏索引
>
>通过在 .MYI 文件进行索引的查找，找到要查找元素的相应内存位置，然后会在 .MYD 文件中进行查找。
>
>用得少的原因：

###### 2.2 InnoDB

>.frm 文件：表的结构，数据结构 之类的
>
>.ibd 文件：表的索引，和数据，B+ 树结构，是聚集索引。
>
>主键索引：通过在 .ibd 中查找相应的索引，定位到相应的位置，然后直接取出数据。
>
>非主键索引（二次索引）：叶子节点不带有该索引结果的所有数据，仅仅带有其结果数据的主键，然后先通过索引查找到主键，然后到主键索引中查找相应的数据。稀疏索引。

##### 3. 索引种类

###### 3.1 聚集索引

>索引和数据放在一起

###### 3.2 非聚集索引

>稀疏索引
>
>索引和数据不放在一起

###### 3.3 索引失效



##### 4. 联合索引

>创建索引的时候如何进行比较？
>
>会根据创建的索引的先后顺序，逐个进行字段的比较。如果第一个字段可以比较出大小，则直接比较出大小，否则比较后面的字段。

##### 5. 索引优化原则

###### 5.1 最左前缀faze

>对联合索引的表进行查找的话，如果查询条件不是创建索引的字段顺序进行的话（表索引的创建是按照创建索引的时候字段的先后进行比较的），就无法使用索引进行查找。
>
>因为假设进行范围查找的话，联合索引的第一个字段是姓名，然后是年龄，然后 B+ 树会先依据姓名进行排序，然后再根据年龄。而如果直接用年龄作为条件的话，则存在，当你找到条件里面的年龄的时候，年龄以后全部取出，但是首先是根据姓名进行排序，所以你取出来的其实不是根据年龄排序的，而是姓名排好序之后的第一个年龄符合要求的，
>
>****
>
>



##### x. 面试知识点

###### x.1 为什么 InnoDB 必须建有主键，而且主键一般推荐自增主键

>如果创建表的时候不手动创建，MySQL 底层会自动帮助从第一列开始找一个每一列数据都是唯一的一列，创建 B+ 树结构的索引。如果找不到的话，会自己帮你创建你看不见的索引。
>
>****
>
>一般使用整数类型的自增主键，不使用 UUID 作为主键。
>
>创建 B+ 树的时候需要进行很多次比较，然后进行排序创建 B+ 树，整数类型更加有利于进行排序，而且 UUID 一般都比较长。
>
>整型类型占有的内存空间更加小，生产环境下硬盘空间很珍贵。
>
>****
>
>B+ 树要保持其数据结构，所以其中每个节点的索引都是动态变化的，而如果当时自增主键的时候，随着索引的添加，索引都是往后面添加的，整体的索引变化较小，而如果不是自增的话，索引大小随时变化，则每个节点的索引变化可能较大，会产生多余的消耗。（主要是影响 insert 语句的效率）



###### x.2 为什么非主键索引结构叶子节点存储的是主键值（一致性和节省空间）





###### x.3 java 连接数据库的步骤





>数据库优化
>
>幻读
>
>间隙锁
>
>数据库切换：垂直切分水平切分
>
>MySQL 索引，优化
>
>索引实现方式
>
>数据库分表，分表依据
>
>怎么判断有没有走索引
>
>索引优化	
>
>聚簇索引，二级索引，联合索引
>
>ACID
>
>事务隔离级别，常用
>
>InnoDB 存储方式
>
>死锁，乐观锁，悲观锁
>
>脏数据
>
>MVCC机制实现原理
>
>innoDB
>
>MySQL的几种连接
>
>索引建在什么列上
>
>数据库的主从架构中，使用了哪些线程，哪些是从库的，哪些是主库的	
>
>sql中where，group by，having，order by的执行顺序
>
>三大范式
>
>怎么查看有没有索引
>
>左右 内连接
>
>慢查询
>
>几十万大数据表设计

### 非关系型数据库

>KV 键值
>
>Redis
>
>****
>
>文档型数据库
>
>MongoDB
>
>CouchDB
>
>****
>
>类存储数据库
>
>Cassandra
>
>HBase
>
>****
>
>图关系数据库
>
>Neo4J InfoGrid

#### 1. Redis 远程字典服务

 ##### 1.1 单线程

> 单线程快吗，为什么是单线程
>
> 因为 Redis 是基于内存操作的，所以 CPU（线程轮流获得 CPU） 并不是 Redis 的瓶颈，瓶颈是机器的内存以及网络的带宽。
>
> 其次，Redis 是将所有的数据存放到内存中的，所以单个线程操作的话这样效率最高，因为这样不存在上下文的切换，可以避免多余的时间开销。对于内存系统来说，没有上下文切换效率就是最高的，多次读写都在一个 CPU上，在内存情况下，这样就是最佳的。
>
> ****
>
> 











>redis 底层原理
>
>LRU底层
>
>缓存的三大问题
>
>SpringBoot 中不使用 jredis 使用 lettuce。
>
>zset 底层
>
>大数据怎么处理的，分表依据
>
>内存雪崩，内存击穿，内存穿透 
>
>底层分布
>
>OSI七层协议
>
>Redis 为什么单线程很快
>
>Redis cluster
>
>MongoDB
>
>redis的缓存机制，InnoDB引擎，restful介绍

### JavaSE

>hashmap，concurrenthashmap1.7 1.8点区别，HashMap底层原理，红黑树，hash冲突
>
>CopyOnWriterArrayList
>
>HashMap 加载因子,初始化容量
>
>foreach 参数是什么
>
>为什么 HashMap 头插法会导致死循环。
>
>抽象类和接口
>
>集合底层
>
>内部类 匿名内部类
>
>equals == hashCode
>
>String 底层
>
>深拷贝 浅拷贝
>
>反射
>
>阻塞队列
>
>concurrentHashMap
>
>抽象类，接口
>
>jre,jdk
>
>函数式编程
>
>接口
>
>重载 重写
>
>toString和String.valueOf的区别，toString当对象为null时会怎么样
>
>序列化，反序列化
>
>网络编程
>
>输入输出流
>
>static代码块与static变量等执行顺序
>
>面向对象思想
>
>I/O
>
>

### 并发

#### 1. 集群

>正向代理，反向代理，集群





>消费者生产者
>
>单例模式
>
>
>
>lock 和 sychrinized 锁的区别，为什么 sychrinized 的效率高一点？
>
>volatile，指令重排
>
>线程创建方式
>
>线程池 ThreadLocal 参数
>
>拒绝策略
>
>同步队列
>
>线程通信
>
>Synchronized和ReentraintLock区别
>
>手写单例模式
>
>线程上下文切换系统开销
>
>阻塞队列
>
>乐观锁悲观锁等各种锁
>
>实现多线程的方法
>
>编程实现两个线程循环打印ABABAB
>
>编程实现单例模式
>
>编程实现死锁
>
>





### 数据

>JWT：https://www.jianshu.com/p/576dbf44b2ae
>
>get 和 post 区别
>
>Json
>
>session
>
>token保证安全
>
>cookie
>
>状态码
>
>异步请求
>
>解决跨域

### Spring

>Spring bean 加载
>
>解决循环引用
>
>spring IoC spring AOP
>
>OOM
>
>依赖注入
>
>StringIoC 的创建流程
>
>重写重载
>
>静态代理 动态代理
>
>常用注解
>
>启动过程
>
>FactoryBean 和 BeanFactory
>
>怎么在启动的时候添加一下自己的东西
>
>Spring中有这个对象，用反射再次创建一个这个对象的结果

### MyBatis

>sqlSessiona
>
>'#' 和 $ 区别
>
>执行一个语句的顺序
>
>有哪些 Excutor
>
>插件原理
>
>二级缓存
>
>同时可以有上千个主机连到MyBatis吗
>
>

### 设计模式



>工厂模式
>
>双亲委派模式

## ES

>ES倒排索引原理和ES存储数据的原理，集群配置
>
>

## mvn 

>常用打包命令

## 计网

>TCP UDP 三次握手，四次挥手
>
>IP 地址分配 ABCD类地址
>
>应用层，网络层。。。
>
>Http 请求过程
>
>socket
>
>TCP状态
>
>设置 time_wait
>
>http 和 https : https://blog.csdn.net/xiaoming100001/article/details/81109617

## 计操

>线程，进程的区别
>
>并行，并发
>
>内核态和用户态切换具体过程，操作系统中断 现场保护

## Linux 

> 简单命令



>看技术栈



## 算法

>八大算法问题





## 知识点

### 1. 双亲委派机制



### 2. 类加载器







### 3. 排序方式







## 疑难杂惑

### 1.

![image-20200903172328924](C:\Users\userhan\AppData\Roaming\Typora\typora-user-images\image-20200903172328924.png)

> 栈里面放实例的方法，那方法区里面放什么。

### 2. 

同步请求和异步请求区别

### 3. 

前后端分离解决跨域问题

### 4. 

restful



![image-20200907203157035](C:\Users\userhan\AppData\Roaming\Typora\typora-user-images\image-20200907203157035.png)





## 目标清单

* 写 jar 包:通过 URl 和正则表达式识别出网络资源,然后通过 IO流 与多线程直接下载到本地.
* 写 web 项目:四川师范大学老乡网站





```java
学习别人讲解的东西就像吃别人咀嚼过的东西,但是最恶心的是担心他们吐出来的时候吐错了。
压栈夫人。
经过研究，百分之99的对象都是临时对象。
所以养老区很难进入。
```

​	

